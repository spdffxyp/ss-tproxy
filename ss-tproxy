#!/bin/bash

main_cfg='/etc/ss-tproxy.conf'

if [ ! -e ${main_cfg} ]; then
    echo -e "\e[37m${main_cfg}\e[0m  [\e[1;35mnot_exist\e[0m]"
    exit 1
else
    source ${main_cfg}
fi

function dnsfwd_update() {
cat << EOF > /root/.dnsforwarder/config
# Generated by ss-tproxy at $(date +%F\ %T)

#### 日志相关 ####
LogOn ${dnsforwarder_log_on} # 启用日志
LogFileThresholdLength ${dnsforwarder_log_size} # 日志大小临界值，大于该值则将原文件备份，使用新文件记录日志
LogFileFolder ${dnsforwarder_log_dir} # 日志文件所在的文件夹

#### 监听地址 ####
UDPLocal ${dnsforwarder_listen} # 可以有多个，使用逗号隔开，默认端口53

#### 上游dns ####
UDPGroup ${dnsforwarder_upstream} * on # chinadns 作为上游 dns 服务器
BlockNegativeResponse ${dnsforwarder_upstream_block_negative_response} # 过滤上游 dns 未成功的响应

#### dns缓存 ####
UseCache ${dnsforwarder_cache_on} # 启用缓存（文件缓存）
MemoryCache ${dnsforwarder_cache_use_memory} # 不使用内存缓存
CacheSize ${dnsforwarder_cache_size} # 缓存大小，不能小于 102400

IgnoreTTL ${dnsforwarder_cache_ignore_ttl} # 忽略 TTL 值

ReloadCache ${dnsforwarder_cache_reload_on_start} # 启动时加载已有的文件缓存
OverwriteCache ${dnsforwarder_cache_overwrite_when_reload_failed} # 当已有的文件缓存载入失败时，覆盖原文件
EOF
}
function dnsfwd_flush() {
    if [ $(pgrep -c dnsforwarder) -eq 0 ]; then
        rm -fr /root/.dnsforwarder/cache
    else
        pgrep dnsforwarder | xargs kill -9 &> /dev/null
        rm -fr /root/.dnsforwarder/cache
        dnsforwarder -d &> /dev/null
    fi
}

function chnip_update() {
    chnip_url="http://f.ip.cn/rt/chnroutes.txt"
    chnip_url="https://github.com/koolshare/koolshare.github.io/raw/acelan_softcenter_ui/shadowsocks/shadowsocks/ss/rules/chnroute.txt"
    chnip_txt="/tmp/ss-tproxy_chnip.txt"
    chnip_sh="/tmp/ss-tproxy_chnip.sh"

    echo -n > ${chnip_txt}
    echo -n > ${chnip_sh}

    curl -sL ${chnip_url} | egrep -v '^\s*$|^\s*#' > ${chnip_txt}
    for i in $(cat ${chnip_txt}); do echo "ipset -A chnip ${i}" >> ${chnip_sh}; done

    ipset -L chnip &> /dev/null
    if [ $? -ne 0 ]; then
        ipset -N chnip hash:net
    else
        ipset -F chnip &> /dev/null
    fi

    bash ${chnip_sh}
    ipset -S chnip > ${ipset_save_file}

    rm -fr ${chnip_txt} ${chnip_sh}
}

function ipts_update() {
    iptables -t mangle -F
    iptables -t mangle -X SS-UDP &> /dev/null
    iptables -t nat -F
    iptables -t nat -X SS-TCP &> /dev/null

    iptables -t mangle -N SS-UDP
    iptables -t mangle -A SS-UDP -d 0/8 -j RETURN
    iptables -t mangle -A SS-UDP -d 127/8 -j RETURN
    iptables -t mangle -A SS-UDP -d 10/8 -j RETURN
    iptables -t mangle -A SS-UDP -d 169.254/16 -j RETURN
    iptables -t mangle -A SS-UDP -d 172.16/12 -j RETURN
    iptables -t mangle -A SS-UDP -d 192.168/16 -j RETURN
    iptables -t mangle -A SS-UDP -d 224/4 -j RETURN
    iptables -t mangle -A SS-UDP -d 240/4 -j RETURN
    iptables -t mangle -A SS-UDP -d ${server_addr} -j RETURN
    iptables -t mangle -A SS-UDP -m set --match-set chnip dst -j RETURN
    iptables -t mangle -A SS-UDP -p udp -j TPROXY --tproxy-mark ${iptables_tproxy_mark} --on-ip ${iptables_tproxy_ip} --on-port ${iptables_tproxy_port}

    iptables -t mangle -A PREROUTING -p udp -s ${iptables_intranet} -j SS-UDP

    iptables -t nat -N SS-TCP
    iptables -t nat -A SS-TCP -d 0/8 -j RETURN
    iptables -t nat -A SS-TCP -d 127/8 -j RETURN
    iptables -t nat -A SS-TCP -d 10/8 -j RETURN
    iptables -t nat -A SS-TCP -d 169.254/16 -j RETURN
    iptables -t nat -A SS-TCP -d 172.16/12 -j RETURN
    iptables -t nat -A SS-TCP -d 192.168/16 -j RETURN
    iptables -t nat -A SS-TCP -d 224/4 -j RETURN
    iptables -t nat -A SS-TCP -d 240/4 -j RETURN
    iptables -t nat -A SS-TCP -d ${server_addr} -j RETURN
    iptables -t nat -A SS-TCP -m set --match-set chnip dst -j RETURN
    iptables -t nat -A SS-TCP -p tcp -j REDIRECT --to-ports ${redir_port}

    iptables -t nat -A OUTPUT -p tcp -j SS-TCP
    iptables -t nat -A PREROUTING -p tcp -s ${iptables_intranet} -j SS-TCP

    iptables -t nat -A POSTROUTING -s ${iptables_intranet} -j MASQUERADE
}
function ipts_origin() {
    iptables -t mangle -F
    iptables -t mangle -X SS-UDP &> /dev/null
    iptables -t nat -F
    iptables -t nat -X SS-TCP &> /dev/null

    iptables -t nat -A POSTROUTING -s ${iptables_intranet} -j MASQUERADE
}

function pbr_add() {
    ip route add local 0/0 dev lo table ${pbr_table}
    ip rule add fwmark ${iptables_tproxy_mark} lookup ${pbr_table}
}
function pbr_del() {
    ip rule show | grep "fwmark ${iptables_tproxy_mark}" | awk -F':' '{print $1}' | xargs -n1 ip rule del pref &> /dev/null
    ip route flush table ${pbr_table}
}

function ipfwd_on() {
    if [ $(cat /proc/sys/net/ipv4/ip_forward) -ne 1 ]; then
        echo 1 > /proc/sys/net/ipv4/ip_forward
    fi
}

function dns_update() {
cat << EOF > /etc/resolv.conf
# Generated by ss-tproxy at $(date +%F\ %T)
nameserver 127.0.0.1
EOF
}
function dns_origin() {
cat << EOF > /etc/resolv.conf
# Generated by ss-tproxy at $(date +%F\ %T)
nameserver ${dns_original_1}
nameserver ${dns_original_2}
EOF
}

function current_ip() {
    ip_info=$(curl -sL ip.chinaz.com/getip.aspx | sed -r "s/^\{ip:'(.*)',address:'(.*)'\}$/\1|\2/g")
    my_ip=$(echo ${ip_info} | awk -F'|' '{print $1}')
    my_loc=$(echo ${ip_info} | awk -F'|' '{print $2}')
    echo -e "\e[37mIP:\e[0m ${my_ip}\t\e[37m位置:\e[0m ${my_loc}"
}

function start() {
    if [ ! -e ${chinadns_chnroute} ]; then
        echo -e "\e[37m${chinadns_chnroute}\e[0m  [\e[1;35mnot_exist\e[0m]"
        exit 1
    fi

    if [ ! -e ${chinadns_iplist} ]; then
        echo -e "\e[37m${chinadns_iplist}\e[0m  [\e[1;35mnot_exist\e[0m]"
        exit 1
    fi

    if [ ! -e ${ss_conf} ]; then
        echo -e "\e[37m${ss_conf}\e[0m  [\e[1;35mnot_exist\e[0m]"
        exit 1
    fi

    ss_kcp_param=' '
    if [ ${use_kcp} == 'true' ]; then
        nohup ${kcp_client} -c ${kcp_conf} < /dev/null &>> ${kcp_log} &
        kcp_listen=`cat ${kcp_conf} | grep localaddr | sed -nr 's/.*"([0-9.]+):([0-9]+).*$/\1/p'`
        kcp_port=`cat ${kcp_conf} | grep localaddr | sed -nr 's/.*"([0-9.]+):([0-9]+).*$/\2/p'`
        ss_kcp_param="-s "${kcp_listen}" -p "${kcp_port}
    fi

    verbose_log=' '
    if [ ${redir_verbose} == 'true' ]; then
            verbose_log='-v'
    fi
    nohup ss-redir ${ss_kcp_param} -c ${ss_conf} -b ${redir_addr} -l ${redir_port} -u ${verbose_log} < /dev/null &>> ${redir_log} &

    verbose_log=' '
    if [ ${tunnel_verbose} == 'true' ]; then
            verbose_log='-v'
    fi
    nohup ss-tunnel -c ${ss_conf} -b ${tunnel_addr} -l ${tunnel_port} -L ${tunnel_upstream} -u ${verbose_log} < /dev/null &>> ${tunnel_log} &

    verbose_log=' '
    if [ ${local_verbose} == 'true' ]; then
            verbose_log='-v'
    fi
    nohup ss-local ${ss_kcp_param} -c ${ss_conf} ${verbose_log} < /dev/null &>> ${local_log} &

    verbose_log=' '
    if [ ${chinadns_verbose} == 'true' ]; then
            verbose_log='-v'
    fi
    nohup chinadns -b ${chinadns_addr} -p ${chinadns_port} -s ${chinadns_upstream} -c ${chinadns_chnroute} -l ${chinadns_iplist} -m ${verbose_log} < /dev/null &>> ${chinadns_log} &

    dnsfwd_update
    dnsforwarder -d &> /dev/null

    if [ ! -e ${ipset_save_file} ]; then
        chnip_update
    else
        ipset -X chnip &> /dev/null
        ipset -R < ${ipset_save_file}
    fi

    ipts_update

    pbr_add

    ipfwd_on

    dns_update
}

function stop() {
    pgrep kcp_client | xargs kill -9 &> /dev/null
    pgrep ss-redir | xargs kill -9 &> /dev/null
    pgrep ss-tunnel | xargs kill -9 &> /dev/null
    pgrep ss-local | xargs kill -9 &> /dev/null
    pgrep chinadns | xargs kill -9 &> /dev/null
    pgrep dnsforwarder | xargs kill -9 &> /dev/null

    ipts_origin
    ipset -X chnip &> /dev/null
    pbr_del

    dns_origin
}

function status() {
    if [ $(pgrep -c kcp_client) -ge 1 ]; then
        echo -e "\e[37mkcp_client\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mkcp_client\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c ss-redir) -ge 1 ]; then
        echo -e "\e[37mss-redir\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mss-redir\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c ss-tunnel) -ge 1 ]; then
        echo -e "\e[37mss-tunnel\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mss-tunnel\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c ss-local) -ge 1 ]; then
        echo -e "\e[37mss-local\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mss-local\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c chinadns) -ge 1 ]; then
        echo -e "\e[37mchinadns\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mchinadns\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c dnsforwarder) -ge 1 ]; then
        echo -e "\e[37mdnsforwarder\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mdnsforwarder\e[0m\t[\e[1;35mstopped\e[0m]"
    fi
}

function usage() {
{
    echo -e "\e[37mUsage:\e[0m \e[36m${0}\e[0m \e[1;37mCOMMAND\e[0m"
    echo -e "\e[1;37mCOMMAND\e[0m := {"
    echo -e "\t\e[33mstart\e[0m\t\tstart ss-tproxy"
    echo -e "\t\e[33mstop\e[0m\t\tstop ss-tproxy"
    echo -e "\t\e[33mrestart\e[0m\t\trestart ss-tproxy"
    echo -e "\t\e[33mstatus\e[0m\t\tshow ss-tproxy status"
    echo
    echo -e "\t\e[33mcurrent_ip\e[0m\tshow current_ip info"
    echo -e "\t\e[33mflush_dnsche\e[0m\tflush dnsforwarder cache"
    echo -e "\t\e[33mupdate_chnip\e[0m\tupdate ipset-chnip lists"
    echo -e "}"
} | more
}

case ${1} in
start)
    start
    status
    ;;
status)
    status
    ;;
stop)
    stop
    status
    ;;
restart)
    stop
    status
    echo
    start
    status
    ;;

current_ip)
    current_ip
    ;;
flush_dnsche)
    dnsfwd_flush
    ;;
update_chnip)
    chnip_update
    ;;

*)
    usage
    exit 1
    ;;
esac
